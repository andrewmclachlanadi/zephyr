# Analog Devices ADSP-SC59x (Cortex-A55)
#
# Copyright (c) 2020-2023 Analog Devices, Inc. All Rights Reserved.
# This software is proprietary to Analog Devices, Inc. and its licensors.

#
# ADSP-SC59x devices support JTAG and SWD transports.
#
#transport select jtag
#transport select swd

source [find target/swj-dp.tcl]

set CPU_MAX_ADDRESS 0xFFFFFFFF
source [find bitsbytes.tcl]
source [find memory.tcl]
source [find mem_helper.tcl]
source [find mmr_helpers.tcl]
source [find target/adspsc5xx.tcl]
# memory map

set MAP_XML [find target/adspsc59x_memory_map.xml]
set MAP_FILE [open $MAP_XML]
set _MEMORY_MAP [read $MAP_FILE]
close $MAP_FILE

global MEMORY_MAP
global SKIP_RESET

# substitute SDRAM_SIZE and FLASH_SIZE
set MEMORY_MAP [subst $_MEMORY_MAP]
set SKIP_RESET 0

# UserKey

# Uncomment the following 4 lines and change 0x00000000 to key values
#set USERKEY0 0x00000000
#set USERKEY1 0x00000000
#set USERKEY2 0x00000000
#set USERKEY3 0x00000000

if { [info exists USERKEY0] } {
   set  _USERKEY0 $USERKEY0
} else {
   set  _USERKEY0 0x00000000
}

if { [info exists USERKEY1] } {
   set  _USERKEY1 $USERKEY1
} else {
   set  _USERKEY1 0x00000000
}

if { [info exists USERKEY2] } {
   set  _USERKEY2 $USERKEY2
} else {
   set  _USERKEY2 0x00000000
}

if { [info exists USERKEY3] } {
   set  _USERKEY3 $USERKEY3
} else {
   set  _USERKEY3 0x00000000
}

# target config

if { [info exists CHIPNAME] } {
   set  _CHIPNAME $CHIPNAME
} else {
   set  _CHIPNAME adspsc59x
}

# CoreSight Debug Access Port (DAP)
if { [info exists DAP_TAPID ] } {
   set _DAP_TAPID $DAP_TAPID
} else {
   set _DAP_TAPID 0x4ba06477
}

# debug control register
set TAPC_DBG_CTL 0x31131000

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable "adjc_enable_dap $_CHIPNAME.adjc"

# ADI JTAG Controller
if { [info exists ADJC_TAPID ] } {
  set _ADJC_TAPID $ADJC_TAPID
} else {
  set _ADJC_TAPID 0x0282e0cb
}

jtag newtap $_CHIPNAME adjc -irlen 5 -expected-id $_ADJC_TAPID

# Once the JRC is up, enable our TAPs
jtag configure $_CHIPNAME.adjc -event setup "jtag tapenable $_CHIPNAME.cpu"

# GDB target:  Cortex-A5, using DAP
set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_TARGETNAME

cti create $_CHIPNAME.cti -dap $_CHIPNAME.dap -ap-num 1 -ctibase 0x80024000

target create $_TARGETNAME aarch64 -dap $_CHIPNAME.dap -dbgbase 0x80014000 -cti $_CHIPNAME.cti

# Allocate space for flash algorithm
$_TARGETNAME configure -work-area-phys 0x20025000 -work-area-virt 0x20025000 -work-area-size 0x1B000

# Configure flash driver
if { [info exists FLASH_BASE] } {
   set _FLASH_BASE $FLASH_BASE
} else {
   set _FLASH_BASE 0
}

# Flash size is automatically probed
flash bank $_CHIPNAME.flash adspsc59x $_FLASH_BASE 0 0 0 $_TARGETNAME

# handle command that allows skipping a reset on attach
proc skip_reset {} {
   global SKIP_RESET

   set SKIP_RESET 1
}

# system reset
proc adspsc59x_system_reset {} {
   global _CHIPNAME
   global TAPC_DBG_CTL

   set rcu_ctl     0x3108c000
   set rcu_stat    [expr {$rcu_ctl + 0x4}]
   set rcu_crctl   [expr {$rcu_ctl + 0x8}]
   set rcu_crstat  [expr {$rcu_ctl + 0xC}]
   set rcu_bcode   [expr {$rcu_ctl + 0x28}]
   set rcu_msg     [expr {$rcu_ctl + 0x6c}]
   set rcu_msg_clr [expr {$rcu_ctl + 0x74}]

   set cti3_cticontrol  0x3110d000
   set cti3_ctiappset   [expr {$cti3_cticontrol + 0x14}]
   set cti3_ctiappclear [expr {$cti3_cticontrol + 0x18}]
   set cti3_ctiapppulse [expr {$cti3_cticontrol + 0x1c}]
   set cti3_ctiouten2   [expr {$cti3_cticontrol + 0xa8}]
   set cti3_lar         [expr {$cti3_cticontrol + 0xfb0}]

   set a55_reset_msk 0x310AD010

   log_debug "enable all debug in DBG_CTL..."
   mww phys $TAPC_DBG_CTL 0xFFFF

   log_debug "start system reset..."

   # Clear REG_RCU0_MSG
   # *pREG_RCU0_MSG = 0x0
   mww phys $rcu_msg 0

   # Deassert RSTOUT in REG_RCU0_CTL
   # *pREG_RCU0_CTL |= 0x4
   pmmw $rcu_ctl 0x4 0

   # Clear REG_RCU0_STAT
   # *pREG_RCU0_STAT = 0x7000d
   mww phys $rcu_stat 0x7000d

   # Set HALT (bit 2)
   # *pREG_RCU0_BCODE = 0x4
   mww phys $rcu_bcode 0x4

   # Use CTI to do system reset
   # Unlock CTI3 (System CTI)
   # *pREG_CTI3_LAR = 0xC5ACCE55
   log_debug "Unlock CTI3 (System CTI)..."
   mww phys $cti3_lar 0xC5ACCE55

   # Enable CTI3 (System CTI)
   # *pREG_CTI3_CTICONTROL = 1
   log_debug "Enable CTI3 (System CTI)..."
   mww phys $cti3_cticontrol 0x1

   # Connect CTITRIGOUT[2] of CTI3 to channel 2
   log_debug "Connect CTITRIGOUT of CTI3 to channel 2..."
   mww phys $cti3_ctiouten2 0x4

   # Set RESET_CTLRSTMSK for warm reset(debug stays alive)
   $_CHIPNAME.dap writemem 2 $a55_reset_msk 0xB6

   log_debug "system reset asserted"
   mww phys $cti3_ctiapppulse 0x4

   # Wait till Core 0 is idle
   # while((*pREG_RCU0_MSG & BITM_RCU_MSG_C0IDLE) == 0);
   set data 0
   set retry 0
   while { [expr {$data & 0x100}] == 0 } {
      set data [mem_ap_read_reg $rcu_msg]
      set retry [expr {$retry + 1}]
      if { $retry > 20 } break;
   }
   if { $retry > 20 } {
      set msg [format 0x%08x $data]
      log_error "BCODE.HALT failed (REG_RCU0_MSG $msg)"
   }

   # Clear C0IDLE from REG_RCU0_MSG
   # *pREG_RCU0_MSG_CLR = 0x100
   $_CHIPNAME.dap writemem 2 $rcu_msg_clr 0x100

   # Now BOOT is done
   log_debug "system reset done"

   set data [mem_ap_read_reg $rcu_stat]
   show_rcu_stat "REG_RCU0_STAT" $data

   # Show REG_RCU0_MSG
   set data [mem_ap_read_reg $rcu_msg]
   show_rcu_msg "REG_RCU0_MSG" $data

   # clear REG_RCU0_MSG
   $_CHIPNAME.dap writemem 2 $rcu_msg 0

   # clear REG_RCU0_BCODE
   $_CHIPNAME.dap writemem 2 $rcu_bcode 0

   # Disable CTI3 (System CTI)
   $_CHIPNAME.dap writemem 2 $cti3_cticontrol 0
}

# core reset
proc adspsc59x_core_reset {} {
   global _CHIPNAME
   global TAPC_DBG_CTL

   set rcu_ctl       0x3108c000
   set rcu_stat      [expr {$rcu_ctl + 0x4}]
   set rcu_crctl     [expr {$rcu_ctl + 0x8}]
   set rcu_crstat    [expr {$rcu_ctl + 0xC}]
   set rcu_bcode     [expr {$rcu_ctl + 0x28}]
   set rcu_svect0    [expr {$rcu_ctl + 0x2C}]
   set rcu_svect1    [expr {$rcu_ctl + 0x30}]
   set rcu_svect2    [expr {$rcu_ctl + 0x34}]
   set rcu_msg       [expr {$rcu_ctl + 0x6c}]
   set rcu_msg_clr   [expr {$rcu_ctl + 0x74}]

   $_CHIPNAME.dap writemem 2 $TAPC_DBG_CTL 0xFFFF

   # Read BMODE from RCU0_STAT
   set data [mem_ap_read_reg $rcu_stat]
   set bootmode [expr {($data >> 8) & 0xf}]
   log_info "Boot Mode $bootmode"

   log_info "clear RCU regs ..."
   $_CHIPNAME.dap writemem 2 $rcu_ctl 0
   $_CHIPNAME.dap writemem 2 $rcu_crctl 0
   $_CHIPNAME.dap writemem 2 $rcu_crstat 0xFFFFFFF9

   log_info "start core reset ..."

   # Set HALT (bit 2)
   # *pREG_RCU0_BCODE = 0x4
   $_CHIPNAME.dap writemem 2 $rcu_bcode 0x4

   # Set ARM starting address
   # *pREG_RCU0_SVECT0 = 0x40
   $_CHIPNAME.dap writemem 2 $rcu_svect0 0x40

   # Set SHARC cores to entry points
   # *pREG_RCU0_SVECT1 = 0x00500004
   # *pREG_RCU0_SVECT2 = 0x00500004
   $_CHIPNAME.dap writemem 2 $rcu_svect1 0x00500004
   $_CHIPNAME.dap writemem 2 $rcu_svect2 0x00500004

   # clear CRn bit in CRSTAT register( bit is W1C )
   # *pREG_RCU0_CRSTAT = 0x1
   $_CHIPNAME.dap writemem 2 $rcu_crstat 0x1

   # clear CRCTL
   # *pREG_RCU0_CRCTL = 0x0
   $_CHIPNAME.dap writemem 2 $rcu_crctl 0x0

   # set bit 0 in CRCTL
   # *pREG_RCU0_CRCTL |= 0x1
   $_CHIPNAME.dap writemem 2 $rcu_crctl 0x1

   # Wait till Core 0 is in reset
   set data 0
   set retry 0
   while { [expr {$data & 0x1}] == 0 } {
      set data [mem_ap_read_reg $rcu_crstat]
      set retry [expr {$retry + 1}]
      if { $retry > 20 } break;
   }
   if { $retry > 20 } {
      set msg [format 0x%08x $data]
      log_error "Core was not put in reset"
   }

   # small delay to give reset time to take affect
   sleep 100

   log_info "core reset asserted"

   # clear bit 0 in CRCTL
   set data [mem_ap_read_reg $rcu_crctl]
   set rcu_crctl_data  [expr {$data & 0xFFFFFFFE}]
   $_CHIPNAME.dap writemem 2 $rcu_crctl $rcu_crctl_data

   log_info "core reset complete"
}

$_TARGETNAME configure -event reset-assert {
   global _TARGETNAME
   # Make sure core is halted before doing any memory acessess
   if {[$_TARGETNAME curstate] == "running"} { halt}
   adspsc59x_system_reset
   #adspsc59x_core_reset
}

# read register using mem-ap
proc mem_ap_read_reg {register} {
    global _CHIPNAME
    set result [$_CHIPNAME.dap readmem 2 $register]

    return $result
}

# Initialize the eMSI
proc adspsc59x_a55_init_emsi {} {
   set emsi_clk_ctl 0x310C702C

   # Set the Internal Clock Enable bit and wait for clock synchronization
   # *pREG_EMSI0_CLK_CTL |= BITM_EMSI_CLK_CTL_INTERNAL_CLK_EN
   # while(!(*pREG_EMSI0_CLK_CTL & BITM_EMSI_CLK_CTL_INTERNAL_CLK_STABLE))
   pmmw $emsi_clk_ctl 0x1 0x0
   set data [memread32_phys $emsi_clk_ctl]
   while { ![expr {$data & 0x00000002}] } {
      set data [memread32_phys $emsi_clk_ctl]
   }

   # Set the PLL Enable bit and wait for clock synchronization
   # *pREG_EMSI0_CLK_CTL |= BITM_EMSI_CLK_CTL_PLL_EN;
   # while(!(*pREG_EMSI0_CLK_CTL & BITM_EMSI_CLK_CTL_INTERNAL_CLK_STABLE))
   pmmw $emsi_clk_ctl 0x8 0x0
   set data [memread32_phys $emsi_clk_ctl]
   while { ![expr {$data & 0x00000002}] } {
      set data [memread32_phys $emsi_clk_ctl]
   }
}

# default initialization
proc adspsc59x_a55_init {} {
   adspsc59x_a55_init_emsi
}

# Unless USE_CTI is set to 0, CTI is used to restart the Cortex-A5 core
# so system peripherals can be restarted at the same time

if { [info exists USE_CTI] } {
   set _USE_CTI $USE_CTI
} else {
   set _USE_CTI 1
}
if { $_USE_CTI != 0 } {
   log_info "halt and restart using CTI"
   $_TARGETNAME configure -restart-cti-reg-addr 0x3110d01c -restart-cti-channel 1
}

$_TARGETNAME configure -event gdb-attach {
   if {[$_TARGETNAME curstate] == "running"} { halt}

   # read TAPC_IDCODE to get silicon revision
   # silicon revision 0.0 and 0.1 do not support system reset
   set data [mem_ap_read_reg 0x31130000]

   if { $SKIP_RESET == 0 } {
      reset
      halt
   }

   adspsc59x_a55_init

   arm semihosting enable
}

reset_config trst_only

$_TARGETNAME configure -event reset-assert-post "aarch64 dbginit"

gdb_memory_map disable
